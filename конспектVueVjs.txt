вместо диррективы v-on: можно испльзовать @
    @событие = "обработчик"
    v-on (@) дает событие, к которому можно вобще-то можно было обратиться через $event

вместо диррективы v-bind: можно испльзовать :
    :связываемое = "связываемое"



Двустороннее связывание:
    У нас есть две стороны приложения: представление (html структура) и модель (та, что в js vue).
    Нужно связать атрибуты тэга input и значение post.title
    - :атрибут="модель" -связывает представление с моделью
    - @input="модель = $event.target.value;" -связывает модель с представлением (в данном случае с атрибутом event.target.value)

    элемент    |     событие    |     атрибут
    input      |     oninput    |     value
    textarea   |                |
               |                |
    checkbox   |     onchange   |     checked
    radio btn  |                |
               |                |
    списки     |     onchange   |     value

    Альтернативный способ:
        v-model="модель" - автоматически связывает нужный атрибут и модель
        P.s. Если мы использум кастомный компонент ввода вместо стандартного, то есть два случая:
            1) Когда мы указываем в родительском компоненте имя пропа для
            дочернего элемента (кастомного компонента ввода):
                v-model="модель"
            2) И когда не указываем имя пропа:
                v-model:имя="модель"
        Во втором случае пропу присваивается имя поумолчанию - modelValue.
        В дочернем компоненте связывает обычное поле ввода с этим пропом и прокидываем событие, для обновления
        значения в родительском компоненте:
            this.$emit('update:имя',event.target.value)
                
----------------------------------------------

Передача аргументов между компонентами:
    Аргументы передаваемые от родительского компонента дочернему называются props.
        В дочернем компоненте нужно прописать нужны пропсы (у каждого пропа указываем тип: и required: ):
            props:{ }
        В тэге дочернего компонента связываем его props с моделью:
            v-bind:проп="модель"
    Передача аргументов от дочернего компонента родительскому делается через событие.
        Из дочернего компонента прокидываем event:
            this.$emit('название события', аргументы события)
        В родительском компоненте, соответственно, подписываемя на это событие, а потом ловим его и обрабатываем:
            @событие = "обработчик"

----------------------------------------------

Компоненты:
    Чтобы в один компонент вставить другой компонент, нужно в родительском компонентре:
        импортировать его: import компонент from "@/путь до компонента";
        зарегистрировать его: components: { компоненты }
    и он станет доступен, через тэг <имя компонента>
    (Альтернативный способ: в отдельном js файле заимпортировать набор компонентов и из него экспортировать список
    компонентов. Тогда у объекта app в main.js можно вызвать метод component(название компонента, компонент) и
    эти компоненты будут доступны везде без импортов. Такой способ лучше применять для ui элементов, которые много где
    могут пригодиться и каждый из них импортировать, а затем регистрировать было бы накладно)


    Если мы хотим вставить что-то в тело кастомного компонента, в нем нужно прописать тэг <slot></slot>.
    Тогда все, что мы поместили внутри кастомного тэга, вставится в этот слот.
    P.s. слобы бывают именнованые...

    Все стили, обработчики, связывания, применяемые к компонентам, применяются к коневому тэгу этого компонента.

----------------------------------------------
